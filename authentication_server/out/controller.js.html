<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: controller.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: controller.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
const crypto = require("crypto");
const moment = require('moment');
const { UsedNonce, User } = require("./Model");

// array used to store and keep track of last sent challenges
let challengeCache = [];

/** 
 *  @description
 * - This route is called to register a new user inside the application through the public key of its wallet: 
 * this is needed to later store its personal passkeys; the request is a JSON object containing the following parameters:
 * @param WalletPublicKey - associated to new user's wallet (RSA public-key in pem format, then base64 encoded)
 * @returns {} a JSON object containing: flag - boolean value expressing success/failure of operation; message/error - message explaining success/failure reasons 
 */
const registerUser = async (request, response) => {
    try {
        console.log(request.body.walletPublicKey);
        if (!request.body.hasOwnProperty("walletPublicKey")) {
            return response.status(400).json({ flag: false, error: "Missing Wallet public-key" });
        }

        if (!request.body.walletPublicKey) {
            return response.status(400).json({ flag: false, error: "Empty Wallet public-key" });
        }

        const walletPublicKey = request.body.walletPublicKey;

        //creating a new user with an empty wallet
        await User.create({ walletPublicKey: walletPublicKey, wallet: [] });

        return response.status(200).json({ flag: true, message: "New user created successfully" });
    } catch (error) {
        console.log(error);
        return response.status(400).json({ flag: false, error: error });

    }
};



/**
 * @description 
 *  This route is called to register a new passkey inside user's wallet; the request is a JSON object containing the following parameters: 
 * @param walletPublicKey - user's wallet public-key (RSA public-key in pem format, then base64 encoded)
 * @param relyingPartyId - relying party's unique identifier
 * @param relyingPartyName - relying party identification name
 * @param username - user's identifier within relying party's provided service/application
 * @param passkeyPublicKey - passkey's public-key associated to relying party's auhtentication (RSA public-key in pem format, then base64 encoded)
 * @param passkeySecretKeyE2E - passkey's secret-key associated to relying party's authentication (RSA secret-key in pem format, AES-256-CBC encrypted, then base64 encoded)
 * @param passkeySignature - signature computed using wallet's secret-key over passkey's credential option (RSA signature, then base64 encoded)
 * @returns a JSON object containing: flag - boolean value expressing success/failure of operation; message/error - message explaining success/failure reasons
 * 
 */
const registerPasskey = async (request, response) => {
    try {
        if (!request.body.hasOwnProperty("walletPublicKey") || !request.body.hasOwnProperty("relyingPartyId")
            || !request.body.hasOwnProperty("relyingPartyName") || !request.body.hasOwnProperty("username")
            || !request.body.hasOwnProperty("passkeyPublicKey") || !request.body.hasOwnProperty("passkeySecretKeyE2E")
            || !request.body.hasOwnProperty("passkeySignature")) {
            return response.status(400).json({ flag: false, error: "Missing parameters" });
        }

        if (!request.body.walletPublicKey || !request.body.relyingPartyId
            || !request.body.relyingPartyName || !request.body.username
            || !request.body.passkeyPublicKey || !request.body.passkeySecretKeyE2E || !request.body.passkeySignature) {
            return response.status(400).json({ flag: false, error: "Empty parameters" });
        }

        const { walletPublicKey, relyingPartyId, relyingPartyName, username, passkeyPublicKey, passkeySecretKeyE2E, passkeySignature } = request.body;

        const user = await User.findOne({ walletPublicKey: walletPublicKey });
        console.log(user);

        //storing new passkey inside server-side wallet
        user.wallet.push({
            relyingPartyId: relyingPartyId,
            relyingPartyName: relyingPartyName,
            username: username,
            passkeyPublicKey: passkeyPublicKey,
            passkeySecretKeyE2E: passkeySecretKeyE2E,
            passkeySignature: passkeySignature
        });

        await user.save();

        return response.status(200).json({ flag: true, message: "New passkey registered successfully" });

    } catch (error) {
        console.log(error);
        return response.status(400).json({ flag: false, error: error });
    }
};


/** 
 * @description 
 * This route is called by the client application to initiate the authentication process within a specific relying party; the request 
 * is a JSON object containing the following parameters:
 * @param walletPublicKey - user's wallet public-key (RSA public-key in pem format, then base64 encoded)
 * @param relyingPartyId - relying party's unique identifier
 * @returns a JSON object containing: flag - boolean value expressing success/failure of operation; challenge - random nonce to be signed by user in order to prove authentication; error - message explaining failure reasons
*/
const generateChallenge = async (request, response) => {
    try {
        if (!request.query.relyingPartyId || !request.query.walletPublicKey || request.query.walletPublicKey.trim() === "") {
            return response.status(400).json({ flag: false, error: "Missing parameters" });
        }

        const relyingPartyId = request.query.relyingPartyId;
        const walletPublicKey = request.query.walletPublicKey.trim();
        const nonce = crypto.randomBytes(16).toString("hex");

        const hash = crypto.createHash("sha256");

        hash.update(nonce);

        const challenge = hash.digest("hex");

        const user = await User.findOne({ walletPublicKey: walletPublicKey });

        if (!user) {
            return response.status(401).json({ error: "User does not exists" });
        }

        const passkey = user.wallet.find(passkey => passkey.relyingPartyId === relyingPartyId);

        if (!passkey) {
            return response.status(401).json({ error: `User does not have a valid passkey for service: ${relyingPartyId}` });
        }

        // store nonces to keep track of the one been sent and avoid replay attacks
        await UsedNonce.create({ walletPublicKey: walletPublicKey, relyingPartyId: relyingPartyId, challenge: challenge });

        //cache the obtained challenge
        challengeCache.push(challenge);

        return response.status(200).json({ flag: true, challenge: challenge });
    } catch (error) {
        console.log(error);
        return response.status(400).json({ flag: false, error: error });
    }
};


/**
 * @description 
 *  This route is called by the client application to answer to an asymmetric challenge-response; the request is 
 *  a JSON object containing the following parameters: 
 *  @param walletPublicKey - user's wallet public-key (RSA public-key in pem format, then base64 encoded)
 *  @param challenge - random nonce previously received by the user to be signed in order to prove passkey's possession
 *  @param signature - signature computed using passkey's secret-key to be validated by the server
 *  @param relyingPartyId - relying party's unique identifier, in order to authenticate correct user to a specific service
 *  @returns a JSON object containing: flag - boolean value expressing success/failure of operation; error - message explaining failure reasons
*/
const authenticate = async (request, response) => {
    try {
        if (!request.body.hasOwnProperty("walletPublicKey") || !request.body.hasOwnProperty("signature") || !request.body.hasOwnProperty("challenge") ||
            !request.body.hasOwnProperty("relyingPartyId")) {
            //delete last emitted challenges
            await UsedNonce.deleteMany({ $or: challengeCache });
            challengeCache = [];
            return response.status(400).json({ error: "Parameters are missing" });
        }

        if (!request.body.walletPublicKey || !request.body.signature || !request.body.challenge || !request.body.relyingPartyId) {
            await UsedNonce.deleteMany({ $or: challengeCache });
            challengeCache = [];
            return response.status(400).json({ error: "Empty Parameters" });
        }

        const { walletPublicKey, signature, challenge, relyingPartyId } = request.body;

        const user = await User.findOne({ walletPublicKey: walletPublicKey });
        console.log(user);
        if (!user) {
            await authenticationMaterial.deleteOne({ challenge: challenge });
            return response.status(401).json({ error: "User does not exists" });
        }

        const authenticationMaterial = await UsedNonce.findOne({ walletPublicKey: walletPublicKey, relyingPartyId: relyingPartyId, challenge: challenge });

        //challenge was not issued by server or "belongs" to a different user
        if (authenticationMaterial.relyingPartyId !== relyingPartyId) {
            await authenticationMaterial.deleteOne({ challenge: challenge });
            return response.status(401).json({ flag: false, error: "Unauthorized" });
        }

        //check if challenge has not expired
        const currentDate = moment();
        const duration = moment.duration(currentDate.diff(authenticationMaterial.validity));
        const minutesDiff = duration.asMinutes();

        if (minutesDiff > 4) {
            await authenticationMaterial.deleteOne({ challenge: challenge });
            return response.status(401).json({ flag: false, error: "Challenge expired" });
        }

        //check signature
        const verifier = crypto.createVerify('RSA-SHA256');
        verifier.update(challenge);

        //retrieve correct passkey
        const passkey = user.wallet.find(passkey => passkey.relyingPartyId === relyingPartyId);
        //retrieving pem format of passkey public key
        const passkeyPublicKey = atob(passkey.passkeyPublicKey);
        //validate authentication
        const isSignatureValid = verifier.verify(passkeyPublicKey, signature, 'base64');

        if (!isSignatureValid) {
            await authenticationMaterial.deleteOne({ challenge: challenge });
            return response.status(400).json({ flag: false, error: "Authentication failed" });
        }

        //removing the challenge record, in order to allow same user to authenticate to other services
        await authenticationMaterial.deleteOne({ challenge: challenge });

        return response.status(200).json({ flag: true, message: "Authentication succeeded" });
    } catch (error) {
        await authenticationMaterial.deleteOne({ challenge: challenge });
        console.log(error);
        return response.status(400).json({ flag: false, error: error });
    }
};

module.exports = { authenticate, generateChallenge, registerPasskey, registerUser };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#authenticate">authenticate</a></li><li><a href="global.html#generateChallenge">generateChallenge</a></li><li><a href="global.html#registerPasskey">registerPasskey</a></li><li><a href="global.html#registerUser">registerUser</a></li><li><a href="global.html#usedNonceSchema">usedNonceSchema</a></li><li><a href="global.html#userSchema">userSchema</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Tue May 30 2023 20:04:24 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
